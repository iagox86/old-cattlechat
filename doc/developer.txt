Ron Bowes
6793026
74.406 Project

                      Cattle Chat
                   Developer's Guide

INTODUCTION

 This is the developer guide for Cattle Chat.  I'm going to explain
 a little about the protocol and the files involved.  Hopefully, 
 after reading this, it will make sense.


PROTOCOL

 The protocol I wrote is modeled after Battle.net games.  I did this
 because I am very familiar with Battle.net, and I like the protocol
 that they use. I opted not to use the HTTP-style protocol suggested
 in the assignment guide, because I think this one works better, and 
 was easier to implement. 
 
 Each packet has the following structure:
  FF <code> <length> <data>

 The FF byte is to help line up packets.   If a packet somehow gets
 corrupted or there's a client error, bytes will be discarded until
 the FF is reached.  Packets may get lost, but this adds some level
 of recovery.  

 The length is a 2-byte big-endian value representing the length of
 the packet, including the 4-byte header.

 The code is a one-byte value that tells what kind of packet it is.
 Depending on the code, the various packets have different structures.
 To find out the structure for a specific packet, please see types.h.
 Here are the various packets that are sent to/from the server:

 SID_PING - When the client receives SID_PING, he will immediately
  echo it back to the server.   This server uses this to calculate
  his ping time. 

 SID_ERROR - This is sent when the client does something wrong. It
  can be sent in any state, in either direction.

 SID_CLIENT_INFORMATION - The first packet sent from the client to
  the server. Some useful information is sent to the server, which
  includes the client_token,  a nonce value used when the password
  is hashed.

 SID_SERVER_INFORMATION - The first packet sent from the server to
  the client. It sends the client some useful information, such as
  the server_token, which is another nonce value.

 SID_LOGIN - The client sends this to the server to log in. It has
  the username and a SHA-1 hash of the password. 

 SID_LOGIN_RESPONSE - The server's response to SID_LOGIN. It tells
  the client whether or not he successully logged in. 

 SID_CREATE - The client sends this when the user wishes to create
  a new user account.   It contains the username and the password, 
  hashed. 

 SID_CREATE_RESPONSE - The server's response to when a user wishes
  to create a new account.  

 SID_REQUEST_ROOM_LIST - A good idea that I decided I didn't need.

 SID_ROOM_LIST - Another good idea that I decided not to implement

 SID_CHATCOMMAND - When a user writes a message and presses enter,
  this is how it is sent.   It is also used for channel joins, and
  other simple events that the user can send. 

 SID_CHATEVENT - When an event occurs on the server (a user enters
  the channel, a user leaves, etc.), this is sent.  It has several
  subtypes.  See the types.h file for them.  


CHAT EVENTS

 In addition to SID_ server messages, there are also events which
 are denoted by the EID_ prefix. They represent in-channel events
 that the user sees. More information can be found in the types.h
 file. 

 EID_USER_JOIN_CHANNEL - Received when a user joins the channel.

 EID_USER_IN_CHANNEL - Received when a user is in the channel you
  enter.

 EID_USER_LEAVE_CHANNEL - Received when a user leaves the channel
  you're in.

 EID_TOPIC_CHANGED - Would be sent when a new topic is set for the
  channel, but I never implemented that so it's never sent. 

 EID_INFO - An informational message.

 EID_ERROR - An error message.

 EID_TALK - A user talked out loud.

 EID_CHANNEL - You entered a new channel.

 EID_WHISPERTO - You sent an outgoing private (whispered) message.

 EID_WHISPERFROM - You received a private message.


UDP

 The UDP part of the bot is really ugly, and I don't like it; it's
 only there because we were supposed to add it.  I liked the way I
 did it from tcp (with the /channels) command better, but what can
 I say?

 The UDP protocol is really simple.  The client, at any time, from
 any where, sends a UDP packet to the server's port, with only one
 character: a '0' (hex 0x30).   The character can be followed with
 anything else, it will just be ignored. 

 Upon receiving that, the server replies with a UDP packet with an
 integer --  the integer is the number of chatrooms on the server, 
 and also, as it turns out, the number of UDP packets that will be
 sent back.   The server sends back that many UDP packets, each of
 which contains a string that should just be printed.   The string
 is in the forum "x <y users>", where x is the name of the channel
 and y is the number of users in it. 


PASSWORD

 Passwords are hashed in two different ways.  When logging on, the
 password is hashed with two nonce values, generated by the server
 and the client.   On the client side, the SHA1 of the password is
 taken normally, then that SHA1 value is hashed a second time with
 the server and client token H(c, s, H(password)).   On the server
 side,  the stored password is already hashed  (since accounts are 
 created with the hashed password, the real password is never even
 seen by the server),  the server calculates H(c, s, stored_pass).
 The server compares his to the user's to see if he can log in. 


SERVER IMPLEMENTATION

 In this section, I will go over the main data structures and the
 important points.  

 When a user connects to the server,he is placed in the new_users
 list.  It is designed for users who are in the process of making
 a connection, but haven't given a username yet.   When they have
 authenticated (username/password),  they are moved to a table of
 users called old_users.  

 The list of  currently created chatrooms is stored in a table in
 the main file.   When a user joins a new room, it checks that if
 the room already exists;  if it doesn't, it creates the room and
 adds it to the list. Each room contains a table of the users who
 are in the room.   I decided not  to give rooms unique numerical 
 ID numbers; rather, they are identified by the name/topic. 

 The sockets are stored in the user structure, which is either in 
 new_users or old_users.  There is only ever a single thread at a
 time, and the data is received using the select() function. When
 select() returns,  the appropriate action is taken on any active
 sockets.  

 There isn't really much more to say about the server. My code is
 generously commented,  so for more information please see those.


CLIENT IMPLEMENTATION

 There isn't a lot to say about the client.  The interface for it
 is done in ncurses. There are two reasons for this: the first is
 that I think ncurses is really elegant and nice looking, and the
 second is that I had never used it before,  and always wanted to
 learn how.   It is compatible with both Linux and Solaris, which
 is a definite plus.  

 When connecting,  select() is used to poll the UDP socket, since
 select() is allowed to time out.  For the actual input, select()
 is also used,  to switch between the connected socket and stdin.
 The user's input is read in one character at a time, which isn't
 very clean, but I am unaware of a better way to separate the two
 parts (stdin and the socket). 

 For more information on the client,  have a look at the code and
 the comments.  The code is generously commented. 


STABILITY

 The server can be crashed (with an assertion failure), just by a
 user sending an invalid packet (too short). That isn't really an
 issue on a small assignment, though,  so hopefully that won't be
 taken into account. 
 
CONCLUSION

 That's pretty much all the important stuff to keep in mind.  For
 information on how to use the server, please see the user guide.
 
